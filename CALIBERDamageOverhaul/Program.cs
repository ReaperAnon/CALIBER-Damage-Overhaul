//#define READMODE

using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Fallout4;
using Mutagen.Bethesda.FormKeys.Fallout4;
using Noggog;
using Newtonsoft.Json;
using Mutagen.Bethesda.Plugins;
using CommandLine;
using System.Reflection.Metadata.Ecma335;
using DynamicData.Kernel;

namespace CALIBERDamageOverhaul
{
    public class Program
    {
        private static Lazy<ModSettings> _Settings = null!;

        public static ModSettings Settings => _Settings.Value;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<IFallout4Mod, IFallout4ModGetter>(RunPatch)
                .SetAutogeneratedSettings("settings", "settings.json", out _Settings)
                .SetTypicalOpen(GameRelease.Fallout4, "YourPatcher.esp")
                .Run(args);
        }

#if READMODE
        public class Schema
        {
            public string AmmoLink { get; set; } = "Null";
            public float AmmoDamage { get; set; } = 0f;
            public bool AutomaticMode { get; set; } = false;
            public string TargetToKill { get; set; } = "Null";
            public uint ShotsToKill { get; set; } = 1;
        }

        public class AmmoSchema
        {
            public List<Schema> AmmoEntries { get; set; } = new();
        }
#endif

        struct RaceEntry
        {
            public float healthMin;
            public float healthMax;
            public ulong healthSum;
            public ulong numActors;
        }

        private const int NumOptions = 6;

        private static Perk WeaponPerk { get; set; } = null!;

        private static Keyword WeaponTypeEnergy { get; set; } = null!;

        private static List<IFormLinkGetter<IKeywordGetter>> BallisticModKeywords { get; set; } = new();

        private static List<IFormLinkGetter<IRaceGetter>> RacesToProcess { get; set; } = new();

        private static Dictionary<IFormLinkGetter<IRaceGetter>, RaceEntry> RaceEntries { get; set; } = new();

        public static void CreatePerks(IPatcherState<IFallout4Mod, IFallout4ModGetter> state)
        {
            WeaponPerk = new Perk(state.PatchMod, $"CALIBER_WeaponModificationPerk") {
                FormVersion = 131,
                NumRanks = 1,
                Hidden = true
            };

            state.PatchMod.Perks.Add(WeaponPerk);
            for (int i = 0; i < NumOptions; i++)
            {
                PerkCondition condSet = new() {
                    RunOnTabIndex = 1
                };

                ConditionFloat weaponTypeCond = new() {
                    CompareOperator = CompareOperator.EqualTo,
                    ComparisonValue = 1,
                    Data = new FunctionConditionData() {
                        Function = Condition.Function.HasKeyword,
                        RunOnType = Condition.RunOnType.Subject,
                        ParameterOneRecord = i == 0 ? Fallout4.Keyword.WeaponTypePistol :
                                                i == 1 ? Fallout4.Keyword.WeaponTypeRifle :
                                                i == 2 ? Fallout4.Keyword.WeaponTypeShotgun :
                                                i == 3 ? Fallout4.Keyword.WeaponTypeSniper :
                                                i == 4 ? Fallout4.Keyword.WeaponTypeHeavyGun :
                                                WeaponTypeEnergy
                    }
                };

                ConditionFloat ballisticCond = new() {
                    CompareOperator = CompareOperator.EqualTo,
                    ComparisonValue = 1,
                    Data = new FunctionConditionData() {
                        Function = Condition.Function.HasKeyword,
                        RunOnType = Condition.RunOnType.Subject,
                        ParameterOneRecord = Fallout4.Keyword.WeaponTypeBallistic
                    }
                };

                condSet.Conditions.Add(weaponTypeCond);
                if (i < 5)
                    condSet.Conditions.Add(ballisticCond);

                PerkEntryPointModifyValue accuracyEffect = new() {
                    PerkConditionTabCount = 2,
                    Conditions = new ExtendedList<PerkCondition>() { condSet },
                    EntryPoint = APerkEntryPointEffect.EntryType.ModConeoffireMult,
                    Modification = PerkEntryPointModifyValue.ModificationType.Multiply,
                    Value = 1 - (1 - i == 0 ? Settings.BallisticPistols.AccuracyMult :
                                i == 1 ? Settings.BallisticRifles.AccuracyMult :
                                i == 2 ? Settings.BallisticShotguns.AccuracyMult :
                                i == 3 ? Settings.BallisticSnipers.AccuracyMult :
                                i == 4 ? Settings.BallisticHeavyWeapons.AccuracyMult :
                                Settings.EnergyWeapons.AccuracyMult)
                };

                PerkEntryPointModifyValue damageEffect = new() {
                    PerkConditionTabCount = 2,
                    Conditions = new ExtendedList<PerkCondition>() { condSet },
                    EntryPoint = APerkEntryPointEffect.EntryType.ModWeaponAttackDamage,
                    Modification = PerkEntryPointModifyValue.ModificationType.Multiply,
                    Value = i == 0 ? Settings.BallisticPistols.DamageMult :
                                i == 1 ? Settings.BallisticRifles.DamageMult :
                                i == 2 ? Settings.BallisticShotguns.DamageMult :
                                i == 3 ? Settings.BallisticSnipers.DamageMult :
                                i == 4 ? Settings.BallisticHeavyWeapons.DamageMult :
                                Settings.EnergyWeapons.DamageMult
                };

                PerkEntryPointModifyValue rangeEffect = new() {
                    PerkConditionTabCount = 2,
                    Conditions = new ExtendedList<PerkCondition>() { condSet },
                    EntryPoint = APerkEntryPointEffect.EntryType.ModGunRangeMult,
                    Modification = PerkEntryPointModifyValue.ModificationType.Multiply,
                    Value = i == 0 ? Settings.BallisticPistols.RangeMult :
                                i == 1 ? Settings.BallisticRifles.RangeMult :
                                i == 2 ? Settings.BallisticShotguns.RangeMult :
                                i == 3 ? Settings.BallisticSnipers.RangeMult :
                                i == 4 ? Settings.BallisticHeavyWeapons.RangeMult :
                                Settings.EnergyWeapons.RangeMult
                };

                PerkEntryPointModifyValue piercingEffect = new() {
                    PerkConditionTabCount = 2,
                    Conditions = new ExtendedList<PerkCondition>() { condSet },
                    EntryPoint = APerkEntryPointEffect.EntryType.ModTargetDamageResistance,
                    Modification = PerkEntryPointModifyValue.ModificationType.Multiply,
                    Value = 1 - (1 - i == 0 ? Settings.BallisticPistols.ArmorPen :
                                    i == 1 ? Settings.BallisticRifles.ArmorPen :
                                    i == 2 ? Settings.BallisticShotguns.ArmorPen :
                                    i == 3 ? Settings.BallisticSnipers.ArmorPen :
                                    i == 4 ? Settings.BallisticHeavyWeapons.ArmorPen :
                                    Settings.EnergyWeapons.ArmorPen)
                };

                WeaponPerk.Effects.Add(accuracyEffect);
                WeaponPerk.Effects.Add(damageEffect);
                WeaponPerk.Effects.Add(rangeEffect);
                WeaponPerk.Effects.Add(piercingEffect);
            }
        }

        public static void AddPerks(IPatcherState<IFallout4Mod, IFallout4ModGetter> state)
        {
            // Player
            var perkSpell = new Spell(state.PatchMod, "CALIBER_AddPlayerPerkSpell") {
                FormVersion = 131,
                Type = SpellType.Ability,
                TargetType = TargetType.Self,
                CastType = CastType.ConstantEffect
            };

            state.PatchMod.Spells.Add(perkSpell);
            var perkMGEF = new MagicEffect(state.PatchMod, $"{WeaponPerk.EditorID}MGEF") {
                FormVersion = 131,
                Flags = MagicEffect.Flag.Recover,
                PerkToApply = WeaponPerk.ToLink(),
                Archetype = new MagicEffectArchetype { Type = MagicEffectArchetype.TypeEnum.Script }
            };

            state.PatchMod.MagicEffects.Add(perkMGEF);
            perkSpell.Effects.Add(new Effect {
                BaseEffect = perkMGEF.ToNullableLink(),
                Data = new EffectData()
            });

            var perkQuest = new Quest(state.PatchMod, "CALIBER_AddPlayerPerkQuest")
            {
                FormVersion = 131,
                Data = new QuestData {
                    Flags = Quest.Flag.StartGameEnabled | Quest.Flag.RunOnce
                },
                Aliases = new ExtendedList<AQuestAlias> {
                    new QuestReferenceAlias {
                        ForcedReference = new FormLinkNullable<IPlacedGetter>(Fallout4.PlayerRef.FormKey),
                        Spells = new ExtendedList<IFormLinkGetter<ISpellGetter>>() {
                            perkSpell.ToLinkGetter()
                        }
                    }
                }
            };

            state.PatchMod.Quests.Add(perkQuest);

            // NPC
            var perkString = $"Perk = 0x{WeaponPerk.FormKey.ID:x}~{state.PatchMod.ModKey}|";
            using StreamWriter distrFile = new(state.DataFolderPath + "\\CALIBER Damage Overhaul_DISTR.ini");
            distrFile.WriteLine(perkString + "ActorTypeHuman");
            distrFile.WriteLine(perkString + "ActorTypeGhoul");
            distrFile.WriteLine(perkString + "ActorTypeSuperMutant");
            distrFile.WriteLine(perkString + "ActorTypeSynth");
            distrFile.WriteLine(perkString + "ActorTypeRobot");
            distrFile.WriteLine(perkString + "ActorTypeTurret");
        }

        private static List<string> ForbiddenWords { get; } = new() { "crit", "double", "rad", "shock", "energy", "electric", "fire", "poison" };
        // sucks but whatever
        public static string GetModifiedDescription(string modDesc, bool deleteEntry)
        {
            if (modDesc.IsNullOrEmpty())
                return modDesc;

            if (!modDesc.Contains("damage", StringComparison.OrdinalIgnoreCase))
                return modDesc;

            var dmgIdx = new List<int>();
            var words = modDesc.Trim().Split(' ', StringSplitOptions.TrimEntries).ToList();
            for (int i = 0; i < words.Count; i++) { // save all indexes of the word "damage"
                if (words[i].Contains("damage", StringComparison.OrdinalIgnoreCase))
                    dmgIdx.Add(i);
            }

            for (int i = dmgIdx.Count - 1; i >= 0; i--) { // delete all the ones that have forbidden words reasonably behind them
                if (dmgIdx[i] - 1 > 0 && !words[dmgIdx[i] - 1].Contains('.') && ForbiddenWords.Any(str => words[dmgIdx[i] - 1].Contains(str, StringComparison.OrdinalIgnoreCase)))
                    dmgIdx.RemoveAt(i);
                else if (dmgIdx[i] - 2 > 0 && !words[dmgIdx[i] - 2].Contains('.') && ForbiddenWords.Any(str => words[dmgIdx[i] - 2].Contains(str, StringComparison.OrdinalIgnoreCase)))
                    dmgIdx.RemoveAt(i);
            }

            if (deleteEntry) {
                // find first period before damage word and first period after, then delete the entire span
                for (int i = dmgIdx.Count - 1; i >= 0; i--) {
                    int sentenceBegin = 0;
                    int sentenceEnd = words.Count - 1;
                    for (int j = dmgIdx[i] - 1; j >= 0; j--) { // find begin
                        if (words[j].Contains('.')) {
                            sentenceBegin = j + 1;
                            break;
                        }
                    }

                    for (int j = dmgIdx[i]; j < words.Count; j++) { // find end
                        if (words[j].Contains('.')) {
                            sentenceEnd = j;
                            break;
                        }
                    }

                    // determine if it's the only thing in the sentence within reason, check for "and or ,"
                    bool hasOtherListings = words.GetRange(dmgIdx[i], dmgIdx[i] + 2 < words.Count ? 2 : dmgIdx[i] + 1 < words.Count ? 1 : 0).Any(str => str == "and" || str == "or" || str.Contains(','));
                    if (hasOtherListings) { // remove damage part
                        if (dmgIdx[i] + 1 < words.Count) {
                            if (words[dmgIdx[i] + 1] == "and") // remove following and
                                words.RemoveAt(dmgIdx[i] + 1);

                            if (words[dmgIdx[i] + 1][0] == ',') // remove following comma
                                words[dmgIdx[i] + 1] = words[dmgIdx[i] + 1].Remove(0, 1);
                        }
                        words.RemoveAt(dmgIdx[i]);
                    } else { // remove whole sentence
                        words.RemoveRange(sentenceBegin, sentenceEnd - sentenceBegin + 1);
                    }
                }
            } else {
                // replace entries with "recoil mitigation"
                for (int i = dmgIdx.Count - 1; i >= 0; i--) {
                    words[dmgIdx[i]] = words[dmgIdx[i]].Replace("damage", "recoil mitigation").Replace("Damage", "Recoil mitigation");
                }
            }

            // construct and return the new description string
            string newDesc = "";
            words.ForEach(word => newDesc += word + " ");
            return newDesc.Trim();
        }

        public static void ReplaceWeaponDamageMods(IPatcherState<IFallout4Mod, IFallout4ModGetter> state, IWeaponModificationGetter weaponModGetter, IAObjectModificationGetter objModGetter)
        {
            bool isRechamber = false;
            List<int> dmgMultIdx = new();
            for (int i = 0; i < weaponModGetter.Properties.Count; i++) {
                if (weaponModGetter.Properties[i].Property == Weapon.Property.Ammo)
                    isRechamber = true;

                if (weaponModGetter.Properties[i] is not IObjectModFloatPropertyGetter<Weapon.Property> floatProp)
                    continue;

                if (floatProp.Property != Weapon.Property.AttackDamage)
                    continue;

                if (floatProp.FunctionType != ObjectModProperty.FloatFunctionType.MultAndAdd)
                    continue;

                dmgMultIdx.Add(i);
            }

            if (!dmgMultIdx.Any())
                return;

            dmgMultIdx.Reverse();
            WeaponModification weaponModSetter = (state.PatchMod.ObjectModifications.GetOrAddAsOverride(objModGetter) as WeaponModification)!;
            foreach(var idx in dmgMultIdx) {
                if(isRechamber) {
                    weaponModSetter.Properties.RemoveAt(idx);
                    continue;
                }

                var floatProp = weaponModSetter.Properties[idx] as ObjectModFloatProperty<Weapon.Property>;
                bool isPositive = floatProp!.Value > 0;

                floatProp.Property = Weapon.Property.AimModelRecoilMinDegPerShot;
                floatProp.Value = (float)(floatProp.Value < 0 ? 0.35 : 0.25 * Math.Pow(Math.Abs(floatProp.Value), 0.5));
                if (isPositive)
                    floatProp.Value = -floatProp.Value;
            }

            if(weaponModSetter.Description is not null)
                weaponModSetter.Description = GetModifiedDescription(weaponModSetter.Description!, isRechamber);
        }

        public static IObjectPropertyGetter GetAV(INpcGetter npcGetter, IFormLink<IActorValueInformationGetter> actorValue)
        {
            try {
                return npcGetter.Properties.EmptyIfNull().First(prop => prop.ActorValue.Equals(actorValue));
            }
            catch {
                return new ObjectProperty() { ActorValue = actorValue, Value = 0.0f };
            }
        }

        public static IObjectPropertyGetter GetAV(IRaceGetter raceGetter, IFormLink<IActorValueInformationGetter> actorValue)
        {
            try {
                return raceGetter.Properties.EmptyIfNull().First(prop => prop.ActorValue.Equals(actorValue));
            }
            catch {
                return new ObjectProperty() { ActorValue = actorValue, Value = 0.0f };
            }
        }

        public static float GetTotalAV(IPatcherState<IFallout4Mod, IFallout4ModGetter> state, INpcGetter npcGetter, IFormLink<IActorValueInformationGetter> actorValue)
        {
            if (!npcGetter.Race.TryResolve(state.LinkCache, out var raceGetter))
                throw new Exception($"Could not resolve {npcGetter.Race} for record {npcGetter}");

            return GetAV(raceGetter, actorValue).Value + GetAV(npcGetter, actorValue).Value;
        }


        public static void RunPatch(IPatcherState<IFallout4Mod, IFallout4ModGetter> state)
        {
#if READMODE
            AmmoSchema schema = new AmmoSchema();
            foreach(var ammoGetter in state.LoadOrder.PriorityOrder.WinningOverrides<IAmmunitionGetter>())
            {
                if (ammoGetter.Damage <= 0)
                    continue;

                schema.AmmoEntries.Add(new Schema {
                    AmmoDamage = ammoGetter.Damage > 1 ? ammoGetter.Damage / 10 : ammoGetter.Damage,
                    AmmoLink = ammoGetter.FormKey.ToString() ?? "Null"
                });
            }

            string json = JsonConvert.SerializeObject(schema, (Formatting)1);
            File.WriteAllText("F:\\settings.json", json);
#else
            Console.WriteLine("Creating energy weapon keyword.");
            WeaponTypeEnergy = state.PatchMod.Keywords.AddNew("WeaponTypeEnergy");
            WeaponTypeEnergy.FormVersion = 131;
            WeaponTypeEnergy.Type = Keyword.TypeEnum.None;

            Console.WriteLine("Applying custom ammo damage values.");
            foreach (var ammoEntry in Settings.AmmoEntries)
            {
                if (!ammoEntry.AmmoLink.TryResolve(state.LinkCache, out var ammoGetter))
                    continue;

                if (!ammoEntry.TargetToKill.IsNull && ammoEntry.ShotsToKill > 0)
                    RacesToProcess.Add(ammoEntry.TargetToKill);

                var ammoSetter = state.PatchMod.Ammunitions.GetOrAddAsOverride(ammoGetter);
                ammoSetter.Damage = ammoEntry.AmmoDamage;
            }

            if (RacesToProcess.Any()) {
                Console.WriteLine("Calculating racial health values.");
                foreach (var npcGetter in state.LoadOrder.PriorityOrder.WinningOverrides<INpcGetter>()) {
                    if (npcGetter.Equals(Fallout4.Npc.Player) || npcGetter.UseTemplateActors.HasFlag(Npc.TemplateActorType.Stats))
                        continue;

                    if (!RacesToProcess.Any(entry => entry.Equals(npcGetter.Race)))
                        continue;

                    if (!RaceEntries.TryGetValue(npcGetter.Race, out var raceEntry))
                        raceEntry = new() { healthSum = 0, numActors = 0 };

                    float totalHealth = GetTotalAV(state, npcGetter, Fallout4.ActorValueInformation.Health);
                    if (totalHealth <= 0)
                        continue;

                    ++raceEntry.numActors;
                    raceEntry.healthSum += (ulong)totalHealth;
                    if (raceEntry.healthMin > totalHealth)
                        raceEntry.healthMin = totalHealth;
                    else if (raceEntry.healthMax < totalHealth)
                        raceEntry.healthMax = totalHealth;

                    RaceEntries[npcGetter.Race] = raceEntry;
                }

                Console.WriteLine("Applying autocalculated ammo damage values.");
                foreach (var ammoEntry in Settings.AmmoEntries)
                {
                    if (ammoEntry.TargetToKill.IsNull && ammoEntry.ShotsToKill <= 0)
                        continue;

                    if (!ammoEntry.AmmoLink.TryResolve(state.LinkCache, out var ammoGetter))
                        continue;

                    if (!RaceEntries.TryGetValue(ammoEntry.TargetToKill, out var raceEntry))
                        continue;

                    var healthAvg = (raceEntry.healthSum / raceEntry.numActors + (raceEntry.healthMin + raceEntry.healthMax) / 2) / 2;
                    var ammoSetter = state.PatchMod.Ammunitions.GetOrAddAsOverride(ammoGetter);
                    ammoSetter.Damage = (float)Math.Round(healthAvg / ammoEntry.ShotsToKill);
                    Console.WriteLine($"{ammoSetter}\n\tDamage: {ammoSetter.Damage} (health avg: {healthAvg} | shots: {ammoEntry.ShotsToKill})");
                }
            }

            Console.WriteLine("Applying weapon settings.");
            foreach (var weaponGetter in state.LoadOrder.PriorityOrder.WinningOverrides<IWeaponGetter>()) {
                bool isPlayable = !weaponGetter.Fallout4MajorRecordFlags.HasFlag(Fallout4MajorRecord.Fallout4MajorRecordFlag.NotPlayable);
                bool isBallistic = weaponGetter.HasKeyword(Fallout4.Keyword.WeaponTypeBallistic) || weaponGetter.HasKeyword(Fallout4.Keyword.modskill_Guns);
                bool isEnergy = weaponGetter.HasKeyword(Fallout4.Keyword.WeaponTypeLaser) || weaponGetter.HasKeyword(Fallout4.Keyword.WeaponTypePlasma) ||
                    weaponGetter.HasKeyword(Fallout4.Keyword.WeaponTypeGammaGun) || weaponGetter.HasKeyword(Fallout4.Keyword.modskill_EnergyGuns);

                if (isBallistic) {
                    if (!weaponGetter.Ammo.TryResolve(state.LinkCache, out var ammoGetter) || ammoGetter.Damage <= 1)
                        continue;

                    foreach(var weapKeyword in weaponGetter.Keywords.EmptyIfNull())
                    {
                        if (!weapKeyword.TryResolve(state.LinkCache, out var keywordGetter))
                            continue;

                        if (keywordGetter.Type == Keyword.TypeEnum.ModAssociation)
                            BallisticModKeywords.Add(weapKeyword);
                    }

                    var weaponSetter = state.PatchMod.Weapons.GetOrAddAsOverride(weaponGetter);
                    weaponSetter.BaseDamage = (ushort)Math.Ceiling(weaponSetter.BaseDamage * 0.1f);
                }
                else if (isEnergy) {
                    var weaponSetter = state.PatchMod.Weapons.GetOrAddAsOverride(weaponGetter);
                    weaponSetter.Keywords?.Add(WeaponTypeEnergy);
                }
            }

            Console.WriteLine("Modifying weapon attachments.");
            foreach(var objModGetter in state.LoadOrder.PriorityOrder.WinningOverrides<IAObjectModificationGetter>()) {
                if (objModGetter is not IWeaponModificationGetter weaponModGetter)
                    continue;

                if (weaponModGetter.Properties.Count <= 1) // don't change attachment with just one property (damage modifiers)
                    continue;

                if (weaponModGetter.EditorID?.Contains("ammo", StringComparison.OrdinalIgnoreCase) ?? false) // don't change ammo type attachments
                    continue;

                if (!weaponModGetter.TargetOmodKeywords.EmptyIfNull().Any(entry => BallisticModKeywords.Contains(entry))) // don't change attachments that are not for ballistic weapons
                    continue;

                ReplaceWeaponDamageMods(state, weaponModGetter, objModGetter);
            }

            Console.WriteLine("Creating weapon adjustment perks.");
            CreatePerks(state);
            Console.WriteLine("Distributing weapon adjustment perks.");
            AddPerks(state);
#endif
        }
    }
}
